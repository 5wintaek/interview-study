# Render and Commit

React가 ui를 서빙하는데 3가지 스텝이 있다.
1. Triggering (손님의 주문을 주방에 전달하는 것)
2. Rendering (주방에서 주문한 요리를 준비하는 것)
3. Committing (주문을 테이블로 서빙하는 것)

## Step 1: Trigger a render
컴포넌트가 렌더링 되는 2가지 원인
1. 컴포넌트의 첫번째 렌더링
2. 컴포넌트(혹은 그것의 조상 중 하나가)의 state가 업데이트 되었을 때

### Initial render 
타깃노드에 createRoot를 하고, render메서드를 호출

### Re-renders when state updates
한번 처음 컴포넌트가 렌더링하고, 추가 렌더링을 set 함수를 통해 state를 변경함으로써, 야기할 수 있다. 당신의 컴포넌트의 상태를 업데이트 하는 것은 render queue에 추가된다. 

## Step 2: React renders your components
렌더링을 야기하고 나면, 리액트는 스크린에 무엇을 보여줄지 이해하기 위해 당신의 컴포넌트들을 호출한다. 렌더링은 리액트가 컴포넌트를 호출하는 것이다. 
- iniitial render에서는, 리액트가 루트 컴포넌트를 호출할 것이다.
- 연속된 renders에서는, 리액트는 컴포넌트의 상태 업데이트가 그 렌더를 유발한 컴포넌트 함수를 호출할 것이다. 

이러한 프로세스는 재귀적이다. 만일 업데이트된 컴포넌트가 다른 컴포넌트를 return한다면 react는 그 다음 그 컴포넌트를 렌더링할 거고, 그 다음컴포넌트도 무언가를 린턴한다면 그다음다음 컴포넌트를 렌더링할 것이다. 더이상 중첩된 컴포넌트가 없을때까지 지속되고, 그리고나면 리액트는 정확하게 무엇이 화면에 보여져야 하는지 알게 된다.

> 유의 ! <br/>
> 렌더링은 항상 pure한 계산이어야한다.
> 1. 같은 인풋을 넣으면, 같은 결과값이 나와야한다.
> 2. 자신의 일만 처리해야한다. 


> DEEP DIVE <br/>
> 성능 최적화 <br/>
> 업데이트된 컴포넌트가 ui 트리에서 매우 높은 곳에 있다면, 업데이트된 컴포넌트 내에 중첩된 모든 컴포넌트를 렌더링하는 기본 동작은, 성능 최적화되지 않는다.

## Step 3:  React commits changes to the DOM 
- 첫번째 렌더: 리액트는 화면에 만들어진 모든 DOM 노드를 넣기 위해 appendChild() DOM API를 사용할 것이다. 
- 리렌더링: 리액트는 DOM이 최신 렌더링 결과와 매치되게끔 만들기 위해 최소한의 필요한 동작만 실행한다. 
리액트는 렌더링 사이에 변화가 있다면 오로지 그 DOM 노드만 바꾼다.

## Epilogue: Browser paint 
브라우저 렌더링이라고 불리우지만 리액트 렌더링과 혼동을 피하기 위해 여기서는 Browser paint라고 부르겠다. 