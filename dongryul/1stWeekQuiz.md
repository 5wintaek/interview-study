# 1주차 퀴즈 모아보기

## 1. 이터러블이 무엇인가요?
> 이터러블이란 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나, 프로토타입 체인을 통해 상속받아 갖고 있으며 Symbol.iterator 메서드를 호출하면, iterator protocol을 준수한 iterator를 반환하는 객체를 말합니다.

### 1-1. iterator란 무엇인가요?
> iterator란 next 메서드를 소유하며 next 메서드를 호출하면 value와 done property를 갖는 iterator result 객체를 반환하는 객체를 말합니다.

### 1-2. 이터러블과 유사배열객체와는 어떤 차이가 있나요?
> 유사배열객체는 for문으로 순회할 수 있으나, 어쨌거나 일반적인 객체이다. 이터러블처럼 Symbol.iterator 메서드를 갖고 있지 않기 때문에 for...of문으로 순회할 수 없습니다. 하지만 ES6가 되면서 arguments, NodeList, HTMLCollection같은 유사배열객체들이 이터러블이 되었습니다.

### 1-3. Built-In Iterable에는 어떤 것들이 있나요?
> Array, String, Map, Set, TypedArray, arguments, DOM Collection (NodeList, HTMLCollection)이 있습니다.

## 2. Rest 문법과 Spread 문법의 차이점은 무엇인가요?
> rest 문법이란, 함수의 파라미터로 전달된 인자들을 배열로 받아오는 문법입니다. spread 문법이란, 배열이나 객체를 펼쳐서 개별 요소로 분리하는 문법입니다.


## 3. 쿠키란 무엇인가요?
> 쿠키란 웹사이트를 방문할 때 생성되는 정보를 담은 작은 파일로, 클라이언트의 로컬에 저장됩니다. 쿠키는 사용자가 웹사이트를 방문할 때마다 서버로 전송되어 사용자를 식별하는데 사용됩니다.

### 3-1. 쿠키의 동작 방식은 어떻게 되나요?
1. 클라이언트가 서버에 요청을 보냅니다.
2. 서버는 요청을 받아 쿠키를 생성합니다.
3. 서버는 생성된 쿠키를 응답 헤더에 담아 클라이언트에게 전송합니다.
4. 클라이언트는 쿠키를 저장합니다.
5. 클라이언트가 다시 서버에 요청을 보낼 때, 쿠키를 요청 헤더에 담아 서버에 전송합니다.
6. 서버는 클라이언트가 전송한 쿠키를 읽어 사용자를 식별합니다.

### 3-2. 쿠키의 사용 목적은 무엇인가요?
- 사용자를 식별하기 위해 사용됩니다.
- 사용자의 선호 설정을 저장하기 위해 사용됩니다.
- 장바구니에 상품을 담거나, 로그인 정보를 저장하기 위해 사용됩니다.

### 3-3. 쿠키의 단점은 무엇인가요?
- 쿠키는 사용자의 로컬에 저장되기 때문에 보안에 취약합니다.
- 쿠키는 사용자의 로컬에 저장되기 때문에 사용자의 로컬에 저장된 쿠키를 삭제하지 않는 한 계속해서 서버로 전송됩니다.
- 쿠키는 사용자의 로컬에 저장되기 때문에 저장할 수 있는 데이터의 크기가 제한적입니다.

### 3-4. 쿠키의 구조는 어떻게 되나요?
- 쿠키는 이름, 값, 만료 날짜, 경로, 도메인, 보안 여부 등의 정보를 담고 있습니다.
- 쿠키는 `name=value; expires=날짜; path=경로; domain=도메인; secure`와 같은 형식으로 구성되어 있습니다.
- 쿠키는 `document.cookie`를 통해 생성하거나 읽을 수 있습니다.
- 쿠키는 `Set-Cookie` 헤더를 통해 생성하거나 읽을 수 있습니다.

### 3-5. 쿠키의 보안을 위한 방법은 무엇인가요?
- 쿠키에 중요한 정보를 담지 않는 것이 좋습니다.
- 쿠키에 보안을 위한 옵션을 설정하는 것이 좋습니다. (secure, httpOnly, SameSite)
- 쿠키의 만료 날짜를 설정하여 보안을 강화하는 것이 좋습니다.
- 쿠키를 사용할 때는 HTTPS를 사용하는 것이 좋습니다.

## 4. 콜백 패턴이란 무엇인가요?
> 콜백 함수란 다른 함수의 인자로 넘겨주는 함수를 말합니다. 콜백 패턴은 비동기 작업을 처리하기 위한 패턴으로, 비동기 작업이 완료되면 콜백 함수를 호출하여 결과를 전달합니다.

## 5. 호이스팅이란 무엇인가요?
> 변수나 함수의 선언문이 마치 코드의 최상단으로 끌어올려지는 듯이 동작하는 자바스크립트 고유의 특징입니다.

### 5-1. 호이스팅이 발생하는 이유는 무엇인가요?
- 자바스크립트 엔진이 코드를 실행하기 전에 선언문을 먼저 처리하기 때문에 발생합니다

### 5-2. 호이스팅이 함수 선언문과 함수 표현식에 따라 어떻게 다른가요?
- 함수 선언문은 함수를 선언하면서 동시에 초기화하기 때문에 함수 선언문은 전체가 호이스팅됩니다.
- 함수 표현식은 변수에 함수를 할당하기 때문에 변수만 호이스팅되고 함수는 호이스팅되지 않습니다.

### 5-3. var 대신 let이나 const로 선언하는 것과의 호이스팅에서의 차이는 무엇인가요?
- var는 선언과 초기화가 동시에 이루어지기 때문에 호이스팅이 발생하고, let과 const는 선언과 초기화가 분리되어 있기 때문에 호이스팅이 발생하지 않는 것처럼 보입니다.

### 5-4. var, let, const의 차이점은 무엇인가요?
- var는 함수 스코프를 가지고 있어서 함수 내에서만 유효한 변수를 선언할 수 있습니다.
- let과 const는 블록 스코프를 가지고 있어서 블록 내에서만 유효한 변수를 선언할 수 있습니다.


## 6. 클로저란 무엇인가요?
> **클로져**는 자신을 포함하고 있는 외부 함수보다 내부 함수가 더 오래 유지되는 경우,
외부 함수 밖에서 내부 함수가 호출되더라도 자신이 생성된 환경을 기억하는 습성을 활용하여
**외부 함수의 지역 변수에 접근할 수 있는 함수** 를 말합니다.

## 7. 이벤트 루프란 무엇인가요?
> 이벤트 루프는 태스크가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없는 경우엔 잠드는, 끊임없이 돌아가는 자바스크립트 내 루프입니다


## 8. 이벤트 위임이란 무엇인가요?
> 여러 개의 하위 DOM 요소에 각각의 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 기법을 말합니다. 이벤트 버블링과 캡처링과 같은 이벤트 전파를 이용한 프로그래밍 패턴입니다. 


## 9. 프로미스란 무엇인가요?
> Promise는 자바스크립트에서 비동기 작업을 처리하기 위한 객체입니다. 비동기 작업이 완료되면 이행할지(rejected) 거부할지(resolve) 결정됩니다.

### 9-1. 프로미스의 상태는 어떤 것들이 있나요?
Promise는 대기(pending), 이행(fulfilled), 거부(rejected)의 세 가지 상태를 가집니다.

- 대기: 비동기 작업이 완료되지 않은 초기 상태
- 이행: 비동기 작업이 성공적으로 완료된 상태
- 거부: 비동기 작업이 실패한 상태

### 9-2. 프로미스의 장점은 무엇인가요?
- 콜백 패턴 대비 비동기 코드를 더 읽기 쉽게 만들어줍니다.
- 에러 처리가 콜백 패턴보다 더 쉽습니다.

### 9-3. 프로미스 체이닝이란 무엇인가요?
- Promise 체이닝은 여러 개의 비동기 작업을 순차적으로 실행하고 그 결과를 연결하여 처리하는 방법입니다. 이는 then() 메서드를 사용하여 각 Promise가 이행될 때마다 연결된 함수를 호출함으로써 이루어집니다.

<br/>
<br/>

## 10. 실행 컨텍스트란 무엇인가요?
> 실행 컨텍스트는 자바스크립트 코드가 실행될 때 생성되는 환경을 말합니다. 이 환경에는 변수, 함수 선언, 스코프 체인, this 등의 정보가 포함됩니다.

<br/>
<br/>

## 11. 자바스크립트에서의 this란 무엇인가요?
> 자바스크립트에서 this란, 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수입니다.

### 11-1. 생성자 함수로 호출했을 때?
- 생성자 함수로 호출했을 때, 해당 객체 인스턴스에 바인딩됩니다.

### 11-2. 일반함수로 호출했을 때 ?
- strict모드에서 일반함수로 호출될 경우 undefined이고, 일반모드에서는 전역 객체가 바인딩됩니다. 

### 11-3. 객체의 메서드로 호출했을 때?
일반적으로 객체의 메서드 안에서 this가 사용되며, 이경우 this는 호출한 객체를 의미하게 됩니다.

### 11-4. 이벤트 핸들러로 호출했을 때?
이벤트 리스너 내에서 this는 해당 이벤트를 발생시킨 요소를 가리킵니다.
그러나 일반적인 함수로써 이벤트 핸들러를 정의하면 this는 이벤트를 발생시킨 요소가 아니라 전역 객체를 가리키기 때문에 주의가 필요합니다.

### 11-5. 화살표 함수로 호출했을 때?
화살표 함수는 자신만의 this를 가지지 않습니다. 그래서 상위 스코프의 this를 그대로 가지고 있습니다.