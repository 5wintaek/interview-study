# Describing the UI

## Passing Props to a Component
- Props를 전달하려면 HTML 어트리뷰트를 사용할 때와 마찬가지로 JSX에 props를 추가합니다.
- Props를 읽으려면 `function Avatar({ person, size })` 구조 분해 할당 문법을 사용합니다.
- `size = 100` 과 같은 기본값을 지정할 수 있으며, 이는 누락되거나 `undefined` 인 props에 사용됩니다.
- 모든 props를 `<Avatar {...props} />`로 전달할 수 있습니다. JSX spread 문법을 사용할 수 있지만 과도하게 사용하지 마세요!
- `<Card><Avatar /></Card>`와 같이 중첩된 JSX는 `Card`컴포넌트의 자식 컴포넌트로 나타납니다.
- Props는 읽기 전용 스냅샷으로, 렌더링 할 때마다 새로운 버전의 props를 받습니다.
- Props는 변경할 수 없습니다. 상호작용이 필요한 경우 state를 설정해야 합니다.

## Conditional Rendering
- React에서 JavaScript로 분기 로직을 제어합니다.
- 조건부로 `if` 문과 함께 JSX 식을 반환할 수 있습니다.
- 조건부로 일부 JSX를 변수에 저장한 다음 중괄호를 사용하여 다른 JSX에 포함할 수 있습니다.
- JSX에서 `{cond ? <A /> : <B />}`는 “cond이면 `<A />`를 렌더링하고, 그렇지 않으면 `<B />`를 렌더링합니다.” 를 의미합니다.
- JSX에서 `{cond && <A />}`는 “cond이면, `<A />`를 렌더링하되, 그렇지 않으면 아무것도 렌더링하지 않습니다.” 를 의미합니다.
- 위 예시는 흔한 방법이지만, `if`를 선호한다면 사용하지 않아도 됩니다.

## Rendering Lists
- 데이터 컬렉션에서 비슷한 컴포넌트 여러 개를 화면에 표시하고 싶을 때 JavaScript 배열 메서드인 `map()` 과 `filter()` 를 사용하여 배열 데이터를 조작할 수 있다.
- 각각의 배열 항목에 다른 항목에서 고유하게 식별할 수 있는 key를 지정해야 한다. 배열 항목이 정렬 등으로 인해 이동하거나 삽입되거나 삭제될 수 있는 경우 중요하다.

>**Rules of keys**
>1. key는 형제 간에 고유해야하지만 같은 key를 다른 배열의 JSX 노드에 사용해도 괜찮다.
>2. key는 변경되어서는 안 되고 렌더링 중에는 key를 생성하면 안 된다.

## Keeping Components Pure
- JavaScript의 순수함수는 오직 연산만을 수행하기 때문에 컴포넌트를 엄격하게 순수함수로 작성하게 될 경우 코드베이스가 커지더라도 예상밖의 동작이나 버그를 피할 수 있다.

>**순수한 컴포넌트**
>1. 자신의 일에 집중한다. 렌더링전에 존재했던 객체나 변수를 변경하지 않아야 한다.
>2. 같은 입력, 같은 결과물. React 컴포넌트가 같은 입력이 주어진다면 반드시 같은 JSX를 반환.

- 사이드 이펙트는 보통 이벤트 핸들러에 포함되고 컴포넌트 내부에 정의되었다 하더라도 렌더링 중에는 실행되지 않기 대문에 이벤트 핸들러는 순수할 필요가 없다. 

## Uderstanding Your UI as a Tree
- 트리는 요소와 UI 사이의 관계 모델이며, React는 컴포넌트로부터 UI 트리를 생성하고 생성된 UI 트리는 DOM을 렌더링하는데 사용된다. 
- 렌더 트리는 React 앱의 단일 렌더링으로 조건부 렌더링을 사용하면 부모 컴포넌트가 전달된 prop에 따라 다른 자식을 렌더링 가능
- 렌더 트리는 최상위 컴포넌트와 리프 컴포넌트를 식별하는 데 도움이 되고, 이는 데이터 흐름과 렌더링 성능을 이해하고 디버깅하는 데 유용
- 모듈 의존성 트리의 각 노드는 모듈이며, 각 가지는 해당 모듈의 import 문을 나타낸다.
- 번들러는 의존성 트리를 사용하여 포함해야 할 모듈을 결정
- 의존성 트리는 느리게 페인트되는 큰 번들 크기를 디버깅하는 데 유용하며, 어떤 코드를 번들로 묶을지 최적화할 수 있다.

### 참고
- https://react.dev/